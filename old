
local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()

local window = OrionLib:MakeWindow({
    Name = "Sterling Hub",
    HidePremium = false,
})


local statNodeTab = window:MakeTab({
    Name = "Stat Node",
    Icon = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
    PremiumOnly = false
})


local statNodeSection = statNodeTab:AddSection({
    Name = "Unlock Move"
})


local statNodeInput = ""


statNodeSection:AddTextbox({
    Name = "Enter Move Name",
    Default = "Tool Manipulation: Wind Scythe",  
    TextDisappear = false,  -- Keep the text visible after typing
    Callback = function(value)
        statNodeInput = value  -- Store the value entered in the textbox
    end
})

-- Button to redeem the stat node
statNodeSection:AddButton({
    Name = "Redeem Move",
    Callback = function()
        if statNodeInput and statNodeInput ~= "" then
            -- Fire the remote to unlock the stat node
            game:GetService("ReplicatedStorage").Remotes.Server.Data.UnlockStatNode:InvokeServer(statNodeInput)
            
            -- Notify the user that the stat node has been redeemed
            OrionLib:MakeNotification({
                Name = "Move Redeemed",
                Content = "You have redeemed: " .. statNodeInput,
                Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
                Time = 5
            })
        else
            -- If no stat node input is provided, notify the user
            OrionLib:MakeNotification({
                Name = "Error",
                Content = "Please enter a valid stat node.",
                Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
                Time = 5
            })
        end
    end
})


-- Create the Main tab
local mainTab = window:MakeTab({
    Name = "Main",
    Icon = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
    PremiumOnly = false
})

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohTable1 = {
	["type"] = "Exorcise",
	["set"] = "Shijo Town Set",
	["rewards"] = {
		["essence"] = 25,
		["chestMeter"] = 75,
		["exp"] = 8000000,
		["cash"] = 50000
	},
	["rewardsText"] = "$50000 | 8000000 EXP | 25 Mission Essence",
	["difficulty"] = 3,
	["title"] = "Exorcise",
	["amount"] = 1,
	["level"] = 420,
	["grade"] = "Non Sorcerer",
	["subtitle"] = "5 Cursed Spirits"
}

-- Quest Loop Section
local questLoopSection = mainTab:AddSection({
    Name = "Quest Loop"
})

-- Variable to control the quest loop (starts off as false)
local questLoopEnabled = false

-- Function to start the quest loop
local function startQuestLoop()
    while questLoopEnabled do
        -- Fire the remote to take the quest
        game:GetService("ReplicatedStorage").Remotes.Server.Data.TakeQuest:InvokeServer(ohTable1)

        -- Wait for 3 seconds before teleporting to the mission portal
        wait(3)

        -- Teleport the character to workspace.Objects.Portals.Missions (which is a Part)
        local missionPortal = workspace.Objects.Portals.Missions
        if missionPortal and missionPortal:IsA("Part") then
            local character = game:GetService("Players").LocalPlayer.Character
            if character then
                character:SetPrimaryPartCFrame(missionPortal.CFrame)
            end
        end

        -- Wait for another 3 seconds at the portal location
        wait(3)

        -- Simulate pressing the "J" key to teleport to the quest location
        game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.J, false, game)

        -- Wait for 5 seconds before repeating the quest loop (to prevent invoking the quest too quickly)
        wait(5) -- 5-second delay between each quest invocation
    end
end

-- Checkbox to enable or disable the quest loop
questLoopSection:AddToggle({
    Name = "Farm Level(Insta Levels)",
    Default = false,
    Callback = function(value)
        questLoopEnabled = value
        if questLoopEnabled then
            startQuestLoop()  -- Start the quest loop when enabled
        end
    end
})
-- Function to collect chests by interacting with the proximity prompt
local function collectChest()
    -- Iterate over all objects in workspace.Objects.Drops
    for _, drop in pairs(workspace.Objects.Drops:GetChildren()) do
        -- Check if the drop is a model whose name starts with "Chest"
        if drop:IsA("Model") and drop.Name:sub(1, 5) == "Chest" then
            -- Look for the ProximityPrompt in the model
            local proximityPrompt = drop:FindFirstChildOfClass("ProximityPrompt")
            
            if proximityPrompt then
                -- Check if the proximity prompt is enabled (not already collected)
                if proximityPrompt.Enabled then
                    -- Simulate pressing the "E" key to collect the chest
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.E, false, game)
                    wait(1)  -- Wait for the specified time between actions
                end
            end
        end
    end
end

-- Variable to control the auto-collect state
local autoCollectEnabled = false

-- Function to toggle auto-collect
local function toggleAutoCollect(enabled)
    autoCollectEnabled = enabled
    if autoCollectEnabled then
        -- Start the loop to collect chests
        while autoCollectEnabled do
            collectChest()
            wait(1)  -- Wait before checking again
        end
    end
end

-- Automatically set mastery to 500 and cooldown to 0
local function setMasteryTo500()
    local masteries = game:GetService("Players").LocalPlayer.ReplicatedData:WaitForChild("masteries")
    for _, child in ipairs(masteries:GetChildren()) do
        if child:IsA("Folder") then
            local level = child:FindFirstChild("level")
            if level then
                level.Value = 500  -- Set mastery level to 500
            end
        end
    end
end

local function setCooldownTo0()
    local skills = game:GetService("ReplicatedStorage"):WaitForChild("Skills")
    for _, child in ipairs(skills:GetChildren()) do
        if child:IsA("Folder") then
            local cooldown = child:FindFirstChild("Cooldown")
            if cooldown then
                cooldown.Value = 0  -- Set cooldown to 0
            end
        end
    end
end

local function resetCooldowns()  -- This function restores cooldown to default
    local skills = game:GetService("ReplicatedStorage"):WaitForChild("Skills")
    for _, child in ipairs(skills:GetChildren()) do
        if child:IsA("Folder") then
            local cooldown = child:FindFirstChild("Cooldown")
            if cooldown then
                cooldown.Value = 10  -- Reset cooldown to a default value (example: 10 seconds)
            end
        end
    end
end

-- Function to set humanoid health to 0 within a specified range
local function instakillHumanoidsInRange(range)
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character
    if not character then return end

    local humanoids = workspace.Objects.Mobs:GetChildren()

    -- Loop through all humanoids in the workspace and set health to 0 if within range
    for _, mob in ipairs(humanoids) do
        if mob:IsA("Model") and mob:FindFirstChild("Humanoid") then
            local humanoid = mob:FindFirstChild("Humanoid")
            local distance = (character.HumanoidRootPart.Position - mob.HumanoidRootPart.Position).Magnitude
            if distance <= range then
                humanoid.Health = 0  -- Set health to 0 for humanoids within the range
            end
        end
    end
end


-- Gamepass Integration Function (added from your code)
local function grantGamepasses()
    local gamepassIds = {"77102528", "77102481", "77103458", "259500454","77102969"} -- Replace with your game pass IDs
    local player = game:GetService("Players").LocalPlayer
    local replicatedData = player:WaitForChild("ReplicatedData")
    local gamepassesFolder = replicatedData:WaitForChild("gamepasses")

    for _, gamepassId in ipairs(gamepassIds) do
        local gamepassValue = gamepassesFolder:FindFirstChild(gamepassId)

        if not gamepassValue then
            -- If the BoolValue doesn't exist for the gamepass, create and add it
            gamepassValue = Instance.new("BoolValue")
            gamepassValue.Name = gamepassId
            gamepassValue.Value = true
            gamepassValue.Parent = gamepassesFolder
            print("Inserted BoolValue for game pass with ID:", gamepassId)
        else
            print("BoolValue for game pass with ID already exists:", gamepassId)
        end
    end
end

-- Instakill Mobs Section
local instakillSection = mainTab:AddSection({
    Name = "Instakill Mobs"
})

-- Slider to set the range for instakill (0 to 1000 units)
local range = 0
instakillSection:AddSlider({
    Name = "Set Range for Instakill",
    Min = 0,
    Max = 1000,
    Default = 0,
    Callback = function(value)
        range = value
        print("Selected range: " .. range)
    end
})

-- Checkbox to enable or disable instakill
local instakillEnabled = false
local instakillLoopConnection
instakillSection:AddToggle({
    Name = "Enable Instakill",
    Default = false,
    Callback = function(value)
        instakillEnabled = value
        if instakillEnabled then
            -- Start the loop for instakill
            instakillLoopConnection = game:GetService("RunService").Heartbeat:Connect(function()
                instakillHumanoidsInRange(range)
            end)
        else
            -- Stop the loop for instakill
            if instakillLoopConnection then
                instakillLoopConnection:Disconnect()
            end
        end
    end
})

-- Variable to control the auto-teleport state
local teleportEnabled = false
local teleportLoopConnection

-- Function to auto-teleport to the nearest mob within a range
local function autoTeleportToMob(range)
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character
    if not character then return end

    local closestMob
    local closestDistance = math.huge  -- Start with a very large number

    local humanoids = workspace.Objects.Mobs:GetChildren()

    -- Find the closest mob within range
    for _, mob in ipairs(humanoids) do
        if mob:IsA("Model") and mob:FindFirstChild("Humanoid") then
            local humanoid = mob:FindFirstChild("Humanoid")
            local distance = (character.HumanoidRootPart.Position - mob.HumanoidRootPart.Position).Magnitude
            if distance <= range and distance < closestDistance then
                closestDistance = distance
                closestMob = mob
            end
        end
    end

    -- Teleport to the closest mob
    if closestMob then
        character:SetPrimaryPartCFrame(closestMob.HumanoidRootPart.CFrame)
    end
end

-- Checkbox to enable or disable auto teleport
local teleportSection = mainTab:AddSection({
    Name = "Auto Teleport to Mob"
})

-- Slider to set the range for auto teleport (0 to 1000 units)
local teleportRange = 0
teleportSection:AddSlider({
    Name = "Set Range for Auto Teleport",
    Min = 0,
    Max = 1000,
    Default = 0,
    Callback = function(value)
        teleportRange = value
        print("Selected teleport range: " .. teleportRange)
    end
})

-- Checkbox to enable or disable auto teleport
teleportSection:AddToggle({
    Name = "Enable Auto Teleport",
    Default = false,
    Callback = function(value)
        teleportEnabled = value
        if teleportEnabled then
            -- Start the loop for auto teleport
            teleportLoopConnection = game:GetService("RunService").Heartbeat:Connect(function()
                autoTeleportToMob(teleportRange)
            end)
        else
            -- Stop the loop for auto teleport
            if teleportLoopConnection then
                teleportLoopConnection:Disconnect()
            end
        end
    end
})

local serverHopTab = window:MakeTab({
    Name = "Join Low Player",
    Icon = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
    PremiumOnly = false
})

-- Assuming Orion UI is already initialized

local Http = game:GetService("HttpService")
local TPS = game:GetService("TeleportService")
local Api = "https://games.roblox.com/v1/games/"

local _place = game.PlaceId
local _servers = Api.._place.."/servers/Public?sortOrder=Asc&limit=100"

-- Function to list servers with pagination support
function ListServers(cursor)
    local Raw = game:HttpGet(_servers .. ((cursor and "&cursor="..cursor) or ""))
    return Http:JSONDecode(Raw)
end


-- Create the button inside the section to perform the server hopping
serverHopTab:AddButton({
    Name = "Hop to Server",
    Callback = function()
        local Server, Next

        -- Fetch server list and teleport
        repeat
            local Servers = ListServers(Next)
            Server = Servers.data[1]
            Next = Servers.nextPageCursor
        until Server

        -- Teleport to the selected server
        if Server then
            TPS:TeleportToPlaceInstance(_place, Server.id, game:GetService('Players').LocalPlayer)
            print("Teleporting to server with ID: " .. Server.id)
        else
            print("No available servers to hop to.")
        end
    end
})


-- Create the Misc tab
local miscTab = window:MakeTab({
    Name = "Misc",
    Icon = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
    PremiumOnly = false
})

-- Assuming Orion UI is already initialized

-- Initialize a variable to track button clicks
local clickCount = 0

-- Adding section to the Misc tab for "Wipe Your Acc"
local wipeSection = miscTab:AddSection({
    Name = "Wipe Your Acc"
})

-- Create the Wipe Button in the wipeSection
wipeSection:AddButton({
    Name = "Wipe Data(CLICK 4 TIMES)",
    Callback = function()
        -- Increment the click count each time the button is clicked
        clickCount = clickCount + 1

        -- Check if the button has been clicked 4 times
        if clickCount == 4 then
            -- Fire the remote after 4 clicks
            local itemName = "Playful Cloud"  -- The name of the item to be given
            game:GetService("ReplicatedStorage").Remotes.Server.Data.GiveItem:FireServer(itemName)

            -- Check if the remote exists before firing
            if remote then
                remote:FireServer(itemName)
                print("Remote fired for item: " .. itemName)
            else
                print("Remote not found.")
            end

            -- Reset the click count after firing the remote
            clickCount = 0
        else
            -- You can show a message or do something else for the other clicks if needed
            print("Clicked " .. clickCount .. " times.")
        end
    end
})


-- Function to collect chests by interacting with the proximity prompt
local function collectChest()
    -- Iterate over all objects in workspace.Objects.Drops
    for _, drop in pairs(workspace.Objects.Drops:GetChildren()) do
        -- Check if the drop is a model whose name starts with "Chest"
        if drop:IsA("Model") and drop.Name:sub(1, 5) == "Chest" then
            -- Look for the ProximityPrompt in the model
            local proximityPrompt = drop:FindFirstChildOfClass("ProximityPrompt")
            
            if proximityPrompt then
                -- Check if the proximity prompt is enabled (not already collected)
                if proximityPrompt.Enabled then
                    -- Simulate pressing the "E" key to collect the chest
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.E, false, game)
                    wait(1)  -- Wait for the specified time between actions
                end
            end
        end
    end
end

-- Variable to control the auto-collect state
local autoCollectEnabled = false

-- Function to toggle auto-collect
local function toggleAutoCollect(enabled)
    autoCollectEnabled = enabled
    if autoCollectEnabled then
        -- Start the loop to collect chests
        while autoCollectEnabled do
            collectChest()
            wait(1)  -- Wait before checking again
        end
    end
end

-- Checkbox to enable or disable auto-collect
miscTab:AddToggle({
    Name = "Enable Auto-Collect",
    Default = false,
    Callback = function(value)
        toggleAutoCollect(value)  -- Toggle the auto-collect loop based on the checkbox
    end
})


-- Skill Settings Section in Misc
local skillSettingsSection = miscTab:AddSection({
    Name = "Skill Settings"
})

-- Button for assigning mastery to 500
skillSettingsSection:AddButton({
    Name = "500 Masteries",
    Callback = function()
        setMasteryTo500()
        OrionLib:MakeNotification({
            Name = "Masteries Set to 500",
            Content = "All mastery values have been set to 500!",
            Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
            Time = 5
        })
    end
})

-- No Cooldowns Toggle Button
local cooldownToggled = false  -- Track cooldown state
skillSettingsSection:AddButton({
    Name = "Toggle No Cooldowns",
    Callback = function()
        if cooldownToggled then
            resetCooldowns()  -- Restore cooldown to default
            OrionLib:MakeNotification({
                Name = "Cooldowns Restored",
                Content = "Cooldowns have been restored to default values.",
                Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
                Time = 5
            })
        else
            setCooldownTo0()  -- Set cooldown to 0
            OrionLib:MakeNotification({
                Name = "Cooldowns Set to 0",
                Content = "All cooldown values have been set to 0!",
                Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
                Time = 5
            })
        end
        cooldownToggled = not cooldownToggled  -- Toggle the state
    end
})

-- Gamepass Section in Misc
local gamepassSection = miscTab:AddSection({
    Name = "Gamepass"
})

gamepassSection:AddButton({
    Name = "Grant Gamepasses",
    Callback = function()
        -- Call the function to grant the gamepass
        grantGamepasses()
        OrionLib:MakeNotification({
            Name = "Gamepass Granted",
            Content = "Gamepasses have been granted successfully.",
            Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
            Time = 5
        })
    end
})

-- Skill Setup Section in Misc
local skillSetupSection = miscTab:AddSection({
    Name = "Skill Setup"
})

-- Create a dropdown for selecting mode (Innates or Skills)
local modeSelected = "Innates"
skillSetupSection:AddDropdown({
    Name = "Select Mode",
    Options = {"Innates", "Skills"},
    Default = 1,
    Callback = function(value)
        modeSelected = value
    end
})

-- Input box for skill name
local skillName
skillSetupSection:AddTextbox({
    Name = "Enter Skill/Innate Skill",
    Default = "",
    TextDisappear = false,  -- Changed to false so text stays visible
    Callback = function(value)
        print("Entered skill: " .. value)
        skillName = value  -- Store the value entered in the textbox here
    end
})

-- Dropdown for selecting keybind (B, C, etc.)
local keybindSelected = "B"
skillSetupSection:AddDropdown({
    Name = "Select Keybind",
    Options = {"B", "C", "G", "T", "V", "X", "Y", "Z"},
    Default = 1,
    Callback = function(value)
        keybindSelected = value
    end
})

-- Button to assign the skill
skillSetupSection:AddButton({
    Name = "Assign Skill/Innate Skill",
    Callback = function()
        -- Ensure the skillName is set
        if not skillName or skillName == "" then
            OrionLib:MakeNotification({
                Name = "Error",
                Content = "Please enter a skill name.",
                Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
                Time = 5
            })
            return
        end

        -- Handle skill assignment to the selected mode and keybind
        local player = game:GetService("Players").LocalPlayer
        local techniques = player:WaitForChild("ReplicatedData"):WaitForChild("techniques")
        local selectedFolder
        if modeSelected == "Innates" then
            selectedFolder = techniques:WaitForChild("innates")
        elseif modeSelected == "Skills" then
            selectedFolder = techniques:WaitForChild("skills")
        end

        if selectedFolder then
            local stringValue = selectedFolder:FindFirstChild(keybindSelected)
            if stringValue and stringValue:IsA("StringValue") then
                stringValue.Value = skillName
                print("Skill assigned: " .. skillName)
                OrionLib:MakeNotification({
                    Name = "Skill Assigned",
                    Content = "The skill '" .. skillName .. "' has been assigned to " .. keybindSelected,
                    Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
                    Time = 5
                })
            else
                OrionLib:MakeNotification({
                    Name = "Error",
                    Content = "No StringValue found for " .. keybindSelected .. " in " .. modeSelected,
                    Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
                    Time = 5
                })
            end
        else
            OrionLib:MakeNotification({
                Name = "Error",
                Content = "Selected folder (" .. modeSelected .. ") does not exist.",
                Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
                Time = 5
            })
        end
    end
})

-- New section for adding Tools to the Backpack
local toolSection = miscTab:AddSection({
    Name = "Cursed Tool Giver"
})

-- Create an input box for typing the Tool name
local toolNameInput
toolNameInput = toolSection:AddTextbox({
    Name = "Enter Cursed Tool Name",
    Default = "",
    TextDisappear = false,  -- Text remains visible
    Callback = function(value)
        print("Entered cursed tool name: " .. value)
        toolName = value  -- Store the value entered in the textbox
    end
})

-- Button to create and add the Tool to the Backpack
toolSection:AddButton({
    Name = "Give Cursed Tool",
    Callback = function()
        -- Make sure toolName is set before proceeding
        if not toolName or toolName == "" then
            OrionLib:MakeNotification({
                Name = "Error",
                Content = "Please enter a tool name.",
                Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
                Time = 5
            })
            return
        end

        -- Create a new Tool object and add it to the Backpack
        local player = game:GetService("Players").LocalPlayer
        local backpack = player.Backpack

        -- Check if the Tool already exists
        local existingTool = backpack:FindFirstChild(toolName)
        if existingTool then
            OrionLib:MakeNotification({
                Name = "Cursed Tool Already Exists",
                Content = "A Tool with this name already exists in your Backpack.",
                Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
                Time = 5
            })
            return
        end

        -- Create the Tool object
        local tool = Instance.new("Tool")
        tool.Name = toolName
        tool.Parent = backpack  -- Add the tool to the Backpack

        print("Tool '" .. toolName .. "' added to the Backpack.")

        -- Display a notification
        OrionLib:MakeNotification({
            Name = "Tool Added",
            Content = "The tool '" .. toolName .. "' has been added to your Backpack.",
            Image = "rbxassetid://4483345998",  -- Custom icon (use your own if needed)
            Time = 5
        })
    end
})

-- Add the Note section in Misc
local noteSection = miscTab:AddSection({
    Name = "Note"
})

noteSection:AddLabel("Note: The skill format should be like this:")
noteSection:AddLabel("(Innate Name): (Innate Skill) for Innates.")
noteSection:AddLabel("For Domain Expansions, use this format: Domain Expansion: (Domain Name)")

-- Finalize setup and initialize
OrionLib:Init()
